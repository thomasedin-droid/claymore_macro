// Twilight 2000 4E - Claymore Mine Macro
// Creates a 60Â° cone, 100m range with damage zones B, C, D

(async () => {
  // Cgeck if the mine token is selected
  if (canvas.tokens.controlled.length === 0) {
    ui.notifications.warn("You need to choose the claymore token first!");
    return;
  }
  
  const mine = canvas.tokens.controlled[0];
  const gridSize = canvas.grid.size;
  const gridDistance = canvas.scene.grid.distance;
  
  // Function to roll T2K damage
  function rollT2KDamage(zone) {
    const damages = {
      "A": { dice: 12, count: 2, bonus: 4 },
      "B": { dice: 10, count: 2, bonus: 3 },
      "C": { dice: 8, count: 2, bonus: 2 },
      "D": { dice: 6, count: 2, bonus: 1 }
    };
    
    const dmg = damages[zone];
    let totalDamage = dmg.bonus;
    let rolls = [];
    
    for (let i = 0; i < dmg.count; i++) {
      const roll = Math.floor(Math.random() * dmg.dice) + 1;
      rolls.push(roll);
      if (roll >= 6) {
        totalDamage += 1;
      }
    }
    
    return {
      total: totalDamage,
      rolls: rolls,
      formula: `${dmg.count}d${dmg.dice}+${dmg.bonus}`
    };
  }
  
  // Ask the user to click to select direction of the blast
  ui.notifications.info("Click on the map to choose the direction of the claymore mine");
  
  const targetPoint = await new Promise((resolve) => {
    const handler = (event) => {
      const point = event.data.getLocalPosition(canvas.app.stage);
      canvas.app.stage.off("pointerdown", handler);
      resolve(point);
    };
    canvas.app.stage.on("pointerdown", handler);
  });
  
  // BerÃ¤kna riktning (vinkel i radianer)
  const dx = targetPoint.x - mine.center.x;
  const dy = targetPoint.y - mine.center.y;
  const direction = Math.atan2(dy, dx);
  
  // Create three cone templates for different damage zones
  const coneAngle = 60;
  const zones = [
    { distance: 30, color: "#ff0000", label: "B" },
    { distance: 60, color: "#ff8800", label: "C" },
    { distance: 100, color: "#ffff00", label: "D" }
  ];
  
  const templates = [];
  for (let zone of zones) {
    const distanceInGridUnits = zone.distance / gridDistance;
    const distanceInPixels = distanceInGridUnits * gridSize;
    
    const templateData = {
      t: "cone",
      user: game.user.id,
      x: mine.center.x,
      y: mine.center.y,
      direction: Math.toDegrees(direction),
      angle: coneAngle,
      distance: distanceInPixels / canvas.dimensions.distance,
      borderColor: zone.color,
      fillColor: zone.color,
      texture: null,
      hidden: false
    };
    
    const template = await canvas.scene.createEmbeddedDocuments("MeasuredTemplate", [templateData]);
    templates.push({ template: template[0], zone: zone.label, maxDist: zone.distance });
  }
  
  // Find all tokens within the 100m cone
  const allTokens = canvas.tokens.placeables;
  const hitTokens = [];
  
  for (let token of allTokens) {
    if (token.id === mine.id) continue;
    
    const distancePixels = Math.sqrt(
      Math.pow(token.center.x - mine.center.x, 2) + 
      Math.pow(token.center.y - mine.center.y, 2)
    );
    
    const distanceMeters = (distancePixels / gridSize) * gridDistance;
    
    if (distanceMeters > 100) continue;
    
    const tokenAngle = Math.atan2(
      token.center.y - mine.center.y,
      token.center.x - mine.center.x
    );
    
    let angleDiff = Math.abs(tokenAngle - direction);
    if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
    
    const halfConeAngle = (coneAngle / 2) * (Math.PI / 180);
    
    if (angleDiff <= halfConeAngle) {
      let damageZone = "D";
      if (distanceMeters <= 30) damageZone = "B";
      else if (distanceMeters <= 60) damageZone = "C";
      
      const damageRoll = rollT2KDamage(damageZone);
      
      hitTokens.push({
        token: token,
        distance: Math.round(distanceMeters),
        zone: damageZone,
        damage: damageRoll
      });
      
      // Apply damage to the tokens in the blast cone
      if (token.actor) {
        try {
          const currentHP = token.actor.system.health.value || 0;
          const newHP = Math.max(0, currentHP - damageRoll.total);
          await token.actor.update({"system.health.value": newHP});
        } catch (err) {
          console.log(`Kunde inte applicera skada pÃ¥ ${token.name}:`, err);
        }
      }
    }
  }
  
  // Create report
  if (hitTokens.length === 0) {
    ChatMessage.create({
      content: `<h3>ðŸ’¥ Claymore Detonation</h3><p>No targets was hit.</p>`,
      speaker: ChatMessage.getSpeaker()
    });
  } else {
    let messageContent = `<h3>ðŸ’¥ Claymore Detonation</h3><table style="border: 1px solid #999; width: 100%;">
      <tr style="background: #333;">
        <th style="padding: 5px;">MÃ¥l</th>
        <th style="padding: 5px;">AvstÃ¥nd</th>
        <th style="padding: 5px;">Zon</th>
        <th style="padding: 5px;">TÃ¤rningar</th>
        <th style="padding: 5px;">Skada</th>
      </tr>`;
    
    for (let hit of hitTokens) {
      const colorMap = { "B": "#ff0000", "C": "#ff8800", "D": "#ffff00" };
      const rollsText = hit.damage.rolls.map(r => r >= 6 ? `<strong>${r}</strong>` : r).join(", ");
      
      messageContent += `<tr>
        <td style="padding: 5px;">${hit.token.name}</td>
        <td style="padding: 5px;">${hit.distance}m</td>
        <td style="padding: 5px; background: ${colorMap[hit.zone]}; font-weight: bold;">${hit.zone}</td>
        <td style="padding: 5px;">[${rollsText}]</td>
        <td style="padding: 5px; font-weight: bold;">${hit.damage.total}</td>
      </tr>`;
    }
    
    messageContent += `</table><p><em>Damage zones: B (0-30m), C (30-60m), D (60-100m)<br></em></p>`;
    
    ChatMessage.create({
      content: messageContent,
      speaker: ChatMessage.getSpeaker(),
      whisper: game.users.filter(u => u.isGM).map(u => u.id)
    });
  }
  
  // Delete templates after 10 seconds
  setTimeout(async () => {
    for (let t of templates) {
      await t.template.delete();
    }
  }, 10000);
  
})();
